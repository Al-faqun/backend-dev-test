# backend-dev-test
www.viomedia.ru/get/file:backend-dev-test.pdf/


## Проектирование
Я предложил два варианта решения задачи. Первый, ‘Filesystem’, на основании того, что в файловой системе файлы и директории – это разновидности файлов, имеет одну таблицу `files`, со следующей схемой:
1.	`id` int(11) auto_increment primary key
2.	`type` enum(‘file’, ‘folder’)
3.	`name` varchar(256)
4.	parent_id int(11)
И четыре класса: FilesEntity, Folder и File (последние два – классы сущностей), и маппер базы данных FileMapper. Маппер позволяет получить любой из узлов (А или B согласно заданию), список дочерних нод любого узла, рекурсивно, в виде объекта типа Folder, в переменной которого Children содержится массив объектов-детей. Более подробно можете посмотреть в соответствующих файлах в папке /Filesystem на вышеупомянутом гитхабе.
Но поскольку в задании нигде не сказано, что А и B должны быть родственными сущностями, более правильным я счёл другой вариант: ‘Articles’, сущностями в котором являются Разделы и Статьи, которым соответствуют таблицы `sections` и `articles`:

| `sections`    |`articles`     |
| ------------- |-------------|
| 1)`id` int(11) auto_increment primary key |1)`id` int(11) auto_increment primary key|
| 2)`name` varchar(256) | 2)`name` varchar(256)|
| 3)`parent_id` int(11) | 3)`parent_id` int(11)|
|  | 4)`text_filepath` varchar(256)|

Поскольку размер текста статьи вовсе не обязательно должен умещаться в поле text, да и в любом случае это поле ухудшит работу таблицы при выборках, текст статьи предлагаю хранить в файле удобного формата, а путь к этому файлу или другой идентификатор – в переменной text_filepath таблицы articles. 
Мапперы работают по такому же принципу, что и FileMapper, только их два (на каждую таблицу отдельный). Ключевой метод задания ArticleMapper::fetchFromSection позволяет получить объект типа Section, в переменной children которого хранится массив его детей, и так далее, рекурсивно. Пробежаться по такому массиву и получить из него какую угодно информацию не составит никакого труда. 
Подробности работы смотрите в классах папки /Articles.
Про выбор таблицы: в теории, если в бд преобладают операции одного типа (insert/select), для оптимизации теоретически можно использовать тип таблицы myisam (если речь идёт о субд mysql/клонах. Но поскольку в ней отсутствует множество новых возможностей, вроде транзакций, я выбрал знакомую innodb.
2.	Разработка класса

Некоторое беспокойство вызвало требование подавать в конструктор только  айдишник. Вероятно, подразумевалось, что методы работы с БД должны лежать в классе User. Мне, однако, видится, что из соображений модульности лучше разделять сущности и класс связывающий сущность с таблицей в БД, если только у вас нет серьёзных соображений против. Однако, требования я нарушать не стал, вместо эттого введя в класс User статическую переменную  маппер и метод User::SetMapper(), который стоит вызывать перед методом User::GetInstance синглтона. Это, впрочем, не очень красиво и про такое легко забыть, и будь моя воля (а у вас – нет возражений), я бы добавил UserMapper в конструктор вторым параметром. Почему мне не нравится идея работать с БД из сущности? Потому что работа с бд в любом случае потребует объект PDO, который либо придётся создавать внутри класса (а значит, ему придётся подбирать имена и пароли из конфига, а это уже серьёзное расширение обязанностей без весомого повода), либо передавать через конструктор или отдельно. У последнего есть также преимущество в том, что это позволит использовать единственный объект pdo на всё приложение, что позволяет пользоваться транзакциями на несколько таблиц.
Таблица `users` содержит только два поля: `id` и `storage` типа varchar(20000)
Поглядите на код двух классов User и UserMapper. Все их методы тривиальны, отдельно от них упомяну  расшифровку адреса: методы User::set и User::&referenceTo используют ссылку на приватную переменную, чтобы, итерируя, достигнуть нужного (любого) уровня вложенности. Ввиду того, что прямая замена переменной-носителя ссылки повлечет уничтожение приватной переменной, код вышел слегка запутанным.
